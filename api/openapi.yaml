openapi: 3.1.0
info:
  title: Lokan OS Hub API
  version: 0.9.0
  description: App-only, local-first API (no web UI). Matter/Thread/Wi-Fi only.
servers:
  - url: https://hub.local
    description: Local LAN endpoint (mTLS required in prod)

paths:
  /v1/healthz:
    get:
      operationId: getHealthz
      summary: Liveness/health check
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema: { $ref: '#/components/schemas/Health' }

  /v1/topology:
    get:
      operationId: getTopology
      summary: Rooms, devices, scenes
      responses:
        '200':
          description: Topology snapshot
          content:
            application/json:
              schema: { $ref: '#/components/schemas/Topology' }

  /v1/devices/{id}/commands:
    post:
      operationId: postDeviceCommand
      summary: Send a command to a device
      parameters:
        - name: id
          in: path
          required: true
          schema: { type: string }
      requestBody:
        required: true
        content:
          application/json:
            schema: { $ref: '#/components/schemas/CommandRequest' }
      responses:
        '200':
          description: Command accepted
          content:
            application/json:
              schema: { $ref: '#/components/schemas/CommandResponse' }
        '400': { $ref: '#/components/responses/BadRequest' }

  /v1/scenes/{id}/apply:
    post:
      operationId: postSceneApply
      summary: Apply a scene atomically
      parameters:
        - name: id
          in: path
          required: true
          schema: { type: string }
      responses:
        '200':
          description: Plan + result
          content:
            application/json:
              schema: { $ref: '#/components/schemas/SceneApplyResult' }

  /v1/rules:test:
    post:
      operationId: postRulesTest
      summary: Dry-run a rule and return the action plan
      requestBody:
        required: true
        content:
          application/json:
            schema: { $ref: '#/components/schemas/RuleTestRequest' }
      responses:
        '200':
          description: Deterministic simulation result
          content:
            application/json:
              schema: { $ref: '#/components/schemas/RuleTestResult' }
        '400': { $ref: '#/components/responses/BadRequest' }

  /v1/updates/check:
    get:
      operationId: getUpdatesCheck
      summary: Check for update availability and slot status
      responses:
        '200':
          description: Update availability
          content:
            application/json:
              schema: { $ref: '#/components/schemas/UpdateCheckResponse' }

  /v1/updates/apply:
    post:
      operationId: postUpdatesApply
      summary: Stage/apply an update to the inactive slot
      requestBody:
        required: true
        content:
          application/json:
            schema: { $ref: '#/components/schemas/UpdateApplyRequest' }
      responses:
        '202':
          description: Update accepted for staging
          content:
            application/json:
              schema: { $ref: '#/components/schemas/UpdateApplyResponse' }
        '400': { $ref: '#/components/responses/BadRequest' }

components:
  responses:
    BadRequest:
      description: Bad request
      content:
        application/json:
          schema: { $ref: '#/components/schemas/Error' }

  schemas:
    Health:
      type: object
      properties:
        status: { type: string, enum: [ok] }
        service: { type: string }
        time: { type: string, format: date-time }
      required: [status, service, time]

    Topology:
      type: object
      properties:
        rooms:
          type: array
          items: { $ref: '#/components/schemas/Room' }
        devices:
          type: array
          items: { $ref: '#/components/schemas/Device' }
        scenes:
          type: array
          items: { $ref: '#/components/schemas/Scene' }
      required: [rooms, devices, scenes]

    Room:
      type: object
      properties:
        id: { type: string }
        name: { type: string }
      required: [id, name]

    Device:
      type: object
      properties:
        id: { type: string }
        roomId: { type: string }
        name: { type: string }
        capability:
          type: string
          enum: [light, plug, sensor, lock]
        state: { $ref: '#/components/schemas/DeviceState' }
      required: [id, roomId, name, capability, state]

    DeviceState:
      type: object
      additionalProperties: true
      properties:
        on: { type: boolean }
        level: { type: integer, minimum: 0, maximum: 100 }
        locked: { type: boolean }

    Scene:
      type: object
      properties:
        id: { type: string }
        name: { type: string }
        items:
          type: array
          items:
            type: object
            properties:
              deviceId: { type: string }
              desiredState: { $ref: '#/components/schemas/DeviceState' }
            required: [deviceId, desiredState]
      required: [id, name, items]

    CommandRequest:
      type: object
      properties:
        capability: { type: string, enum: [light, plug, sensor, lock] }
        action: { type: string, enum: [set, toggle, lock, unlock] }
        args:
          type: object
          properties:
            on: { type: boolean }
            level: { type: integer, minimum: 0, maximum: 100 }
      required: [capability, action]

    CommandResponse:
      type: object
      properties:
        accepted: { type: boolean }
        deviceId: { type: string }
        appliedState: { $ref: '#/components/schemas/DeviceState' }
      required: [accepted, deviceId]

    RuleTestRequest:
      type: object
      properties:
        triggers: { type: array, items: { type: object } }
        conditions: { type: array, items: { type: object } }
        actions:
          type: array
          items:
            type: object
            properties:
              deviceId: { type: string }
              desiredState: { $ref: '#/components/schemas/DeviceState' }
            required: [deviceId, desiredState]
      required: [triggers, actions]

    RuleTestResult:
      type: object
      properties:
        plan:
          type: array
          items:
            type: object
            properties:
              deviceId: { type: string }
              desiredState: { $ref: '#/components/schemas/DeviceState' }
            required: [deviceId, desiredState]
        warnings:
          type: array
          items: { type: string }
      required: [plan]

    SceneApplyResult:
      type: object
      properties:
        plan:
          type: array
          items:
            type: object
            properties:
              deviceId: { type: string }
              desiredState: { $ref: '#/components/schemas/DeviceState' }
            required: [deviceId, desiredState]
        successCount: { type: integer, minimum: 0 }
        failureCount: { type: integer, minimum: 0 }
      required: [plan, successCount, failureCount]

    UpdateCheckResponse:
      type: object
      properties:
        currentVersion: { type: string }
        availableVersion: { type: string, nullable: true }
        activeSlot: { type: string, enum: [A, B] }
        nextSlot: { type: string, enum: [A, B] }
        canUpdate: { type: boolean }
      required: [currentVersion, activeSlot, nextSlot, canUpdate]

    UpdateApplyRequest:
      type: object
      properties:
        version: { type: string }
        channel: { type: string, enum: [canary, beta, stable], default: stable }
      required: [version]

    UpdateApplyResponse:
      type: object
      properties:
        accepted: { type: boolean }
        stagedVersion: { type: string }
        targetSlot: { type: string, enum: [A, B] }
      required: [accepted, stagedVersion, targetSlot]

    Error:
      type: object
      properties:
        error: { type: string }
        message: { type: string }
        code: { type: integer }
      required: [error, message]
